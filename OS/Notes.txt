Operating System - Part I

1. Turn-Around time = Burst-time + I/O + waiting time
2. CPU time/total CPU time
3. Long term Scheduler (process moved from HD to RAM) and short term scheduler (RAM to CPU) & Medium term Scheduler (RAM to HD)
4. process and program
5. Life Cycle of Process (7 states)	
    - New State 	
    - Ready State	
    - Running State	
    - Waiting Sate or Blocked State or I/O State	
    - Termination State	
    - Suspend Ready
    - Suspend Wait or Suspend Blocked
6. Process Attribute	
    - process ID	
    - Program counter (register)	
    - Process State	
    - General purpose Register	
    - Priority	
    - List of open files	
    - List of open devices	
    - Protection
7. Scheduling, Preemption and Timestamp
8. Degree of Multiprogramming
9. Types of OS 	
    - Batch OS	
    - Multiprogramming OS (1 CPU) (concurrent processing)	
    - Multiprocessing OS (more than 1 CPU) (parallel processing)
10. PCB (Process Control Block)	
    - Stack	
    - Heap	
    - Static and Global Variables	
    - program
11. Passive (program) and Active Entity (process)
12. Types of Scheduler
13. Context of a process (PCB + process attributes)
14. Context Switching.
15. Swapping - swap-in & swap-out
16. Point in time vs Duration in time (Burst time + Turn around time + Waiting time + Response Time)
17. Various times related to a process 	
    - Arrival time	
    - Burst time (execution time)	
    - Completion time	
    - Turn around time (completion time - arrival time) (Burst time + Waiting time + I/O time) (total time inside the RAM)	
    - Waiting time	
    - Response time	
    - I/O time
18. CPU Scheduling Algo	
    - Preemptive 	
    - Non PreemptiveNote 
    - CPU scheduling algo are applied only to process which are in the Ready State.
19. Shortest Job First Scheduling Algo (SJF)	
    - Among the arrived process, process with the least burst time will be given preference.	
    - Non Preemptive Algo	
    - Priority based Algo
20. Gantt Chart
21. Schedule length = completion time of last process - arrival time of first process
22. Throughput - number of process executed / schedule length
23. SRTF (Shortest Remaining Time First Scheduling Algorithm) 	- Preemptive version of SJF.
24. Response Time (waiting time of the process until it get CPU for the 1st time)Note - In any non-preemptive scheduling algorithm Response time = waiting time, But this need not be true for preemptive scheduling algo
25. First Come First Serve (FCFS)	
    - The process with the least arrival time	
    - non-preemptive scheduling algo	
    - It is not a priority based scheduling
26. Starvation problemNote 
    - Any priority based algo will suffer from Starvation
27. Convoy Effect (A smaller process (process with very small execution time) waiting for one big process to get off (release))
28. Throughput - No. of process executed in a unit time
29. LJF (Longest Job First Scheduling Algorithm)	
    - non preemptive	
    - priority based algorithm	
    - Starvation problem exists	
    - Convoy effect problem exists	
    - Throughput is very less	
    - Practically very difficult to implement
30. LRTF (Longest Remaining Time First Scheduling Algorithm)	
    - preemptive	
    - starvation problem exists.	
    - convoy effect problem exists.	
    - throughput is very less	
    - practically difficult to implement
31. Time Quantum (maximum allowable time a process can run without getting preempted)
32. Round Robin Scheduling Algorithm (Time Quantum + FCFS)	
    - it not priority based algo.	
    - it works on the basis of a particular time quantum.		
    - Uses Queue data structure	- very popular and used in most of the OS's today
33. RR observations	- Has time quantum increases the context switching may decrease	
    - Has time quantum increases the response time may increase
34. RR Advantages and Limitations	 
    Advantages	
        - No starvation problem	
        - No convoy-effect problem	
        - Practically Implementable	
        - Response time is also good	
    Limitations	
        - Throughput is good but not as good as SJF, SRTF
35. Priority based Scheduling Algo	
    - Mode: Both preemptive and non-preemptive
36. SRTF with process requiring CPU and I/O time
37. Advantages and Disadvantages of SJF	
    Advantages		
        - Throughput is High	
    Disadvantages	
        - Larger process may wait indefinitely or starve
38. Highest Response Ratio Next Scheduling Algorithm (HRRN)	
    - Mode: non-premptive	
    - Response ratio = (w+b)/b		
    - w: waiting time of a process so far		
    - b: burst time39. Process State Diagram
40. Dispatcher
41. Basics of Binary Number System

#Memory Allocation Techniques
42. Basics of Memory Allocation
43. Address space (collection of addresses)	
    - physical address space (instruction address in the RAM)	
    - logical address space (address of a process)44. Various methods used to read the process to main memory	
    - Contigious Allocation (All the address of the logical address space is placed in a congitious in Phyisical address)		
    - Fixed partitioning (Also called as static partitioning)		
    - Variable partitioning (Also called as dynamic partitioning)	
    - Non-Contigious Allocation45. Disadvantages of Fixed partitioning	
    - Internal Fragmentation problem exists	
    - Process size is limited by the size of the largest partition	
    - Degree of Multiprogramming is limited by the number of partitions
46. Rules of Fixed partition	
    - a partition can hold only one process data	
    - a process can be placed in only one partition and it cannot span across 2 or more partitions
Note: No External Fragmentation problem in Fixed partitioning
47. Variable Paritioning (Dynamic partitioning)	
    - No Internal Fragmentation problem	
    - Degree of Multiprogramming is not limited	
    - Size of a process is not limited by size of largest partition rather it is limited by the size of RAM
Note: Variable partitioning suffers from the problem of External Fragmentation (because of congitious allocation)
48. Memory Allocation Algorithm	
    - First fit	
    - Next fit	
    - Best fit	
    - Worst fit
49. Binary Addressing Revisited	
    - Byte Addressable System
50. Solution for External Fragmentation	
    - Compaction	
    - Paging (Non Contigious Allocation)


#OS PartII
1. Paging (Non Contigious Allocation)	
    - Suffers from internal Fragmentation (but very less only at 2 places that is the last page of the process and page table of a process)
2. How CPU excecutes a process in Contigious Allocation
3. Basics of Paging	
    - Page Size	
    - Frame Size (Fixed size blocks in RAM)
Note: Frame Size and Page Size are always equal	
    - Pages (Blocks of processes)	
    - Frames (Blocks of RAM)	
    - Page Table	
    - Byte Addressable System (Every byte will have a unique address)
Note: External Fragmentation is not possible in the Paging
**3.Paging (revise)	    
    - No. of Frames = PAS(Process Address Space) or RAM size / Frame size	
    - No. of Pages = LAS(Logical Address Space) or Process size / Page size
Note: Frage size and Page size are always equal 
Note: Page table is called as Memory Management Unit	
    - Page Table Size = No. of entries in the Pagetable * size of a single entry of PT
4. Relation between LA, LAS and PA, PAS	
5. Multilevel paging need (when the size of a page table is greater than the frame size)
